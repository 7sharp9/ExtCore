(*

Copyright 2011 Tomas Petricek
Copyright 2013 Jack Pappas

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*)

namespace ExtCore.Collections

open System
open System.Threading
open System.IO
open ExtCore
open ExtCore.Control
open ExtCore.Control.Agents


/// The internal type that represents a value returned as a result of
/// evaluating a step of an asynchronous sequence.
//[<CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueValue)>]
type AsyncSeqItem<'T> =
    private
    | Nil
    | Cons of 'T * AsyncSeq<'T>

/// An asynchronous sequence represents a delayed computation that can be
/// started to produce either Cons value consisting of the next element of the 
/// sequence (head) together with the next asynchronous sequence (tail) or a 
/// special value representing the end of the sequence (Nil)
and AsyncSeq<'T> = Async<AsyncSeqItem<'T>>

/// Computation builder that allows creating of asynchronous 
/// sequences using the 'asyncSeq { ... }' syntax.
type AsyncSeqBuilder () =
    //
    member __.Zero () =
        async { return Nil }

    // This looks weird, but it is needed to allow:
    //
    //   while foo do
    //       do! something
    //
    // because F# translates body as Bind(something, fun () -> Return())
    member this.Return (()) =
        this.Zero ()

    //
    member (*inline*) __.Bind (inp : Async<'T>, body : 'T -> AsyncSeq<'U>) : AsyncSeq<'U> =
        async.Bind (inp, body)

    //
    member (*inline*) __.Delay (generator : unit -> AsyncSeq<'T>) =
        async.Delay generator
        
    //
    member this.Yield value =
        async { return Cons (value, this.Zero ()) }
        
    // TODO : Rename this parameter to something meaningful.
    member __.YieldFrom s = s

    //
    member this.Combine (seq1 : AsyncSeq<'T>, seq2 : AsyncSeq<'T>) =
        async {
        let! v1 = seq1
        match v1 with
        | Nil ->
            return! seq2
        | Cons (h, t) ->
            return Cons (h, this.Combine (t, seq2))
        }

    //
    member this.While (guard, aseq : AsyncSeq<'T>) =
        if guard () then
            this.Combine (aseq, this.Delay (fun () -> this.While (guard, aseq)))
        else this.Zero ()

//
[<AutoOpen>]
module AsyncSeqExtensions =
    // Add asynchronous for loop to the built-in 'async' computation builder.
    type Microsoft.FSharp.Control.AsyncBuilder with
        //
        member this.For (aseq : AsyncSeq<'T>, action : 'T -> Async<unit>) =
            async.Bind (aseq, function
                | Nil ->
                    async.Zero ()
                | Cons (h, t) ->
                    async.Combine (action h, this.For (t, action)))
    
    /// Builds an asynchronous sequence using the computation builder syntax.
    let asyncSeq = AsyncSeqBuilder ()

    /// Tries to get the next element of an asynchronous sequence
    /// and returns either the value or an exception.
    // TODO : Simplify this to use the built-in Async.Catch method.
    let private tryNext (input : AsyncSeq<_>) =
        async {
        try
            let! v = input
            return Choice1Of2 v
        with ex ->
            return Choice2Of2 ex
        }

    // Add additional methods to the 'asyncSeq' computation builder
    type AsyncSeqBuilder with
        //
        member this.TryFinally (input : AsyncSeq<'T>, compensation) =
            asyncSeq {
            let! v = tryNext input
            match v with
            | Choice1Of2 Nil ->
                compensation ()
            | Choice1Of2 (Cons (h, t)) ->
                yield h
                yield! this.TryFinally (t, compensation)
            | Choice2Of2 e ->
                compensation ()
                yield! raise e
            }

        //
        member this.TryWith (input : AsyncSeq<_>, handler : exn -> AsyncSeq<_>) =
            asyncSeq {
            let! v = tryNext input
            match v with
            | Choice1Of2 Nil -> ()
            | Choice1Of2 (Cons (h, t)) ->
                yield h
                yield! this.TryWith (t, handler)
            | Choice2Of2 rest ->
                yield! handler rest
            }

        //
        member this.Using (resource : #IDisposable, binder) =
            this.TryFinally (binder resource, fun () ->
                if box resource <> null then resource.Dispose ())

        /// For loop that iterates over a synchronous sequence (and generates
        /// all elements generated by the asynchronous body)
        member this.For (seq : seq<'T>, action : 'T -> AsyncSeq<'TResult>) =
            let enum = seq.GetEnumerator ()
            this.TryFinally(
                this.While(
                    (fun () -> enum.MoveNext ()),
                    this.Delay (fun () -> action enum.Current)),
                (fun () -> if enum <> null then enum.Dispose ()))

        /// Asynchronous for loop - for all elements from the input sequence,
        /// generate all elements produced by the body (asynchronously). See
        /// also the AsyncSeq.collect function.
        member this.For (aseq : AsyncSeq<'T>, mapping : 'T -> AsyncSeq<'TResult>) =
            asyncSeq {
            let! v = aseq
            match v with
            | Nil -> ()
            | Cons(h, t) ->
                yield! mapping h
                yield! this.For (t, mapping)
            }


/// Module with helper functions for working with asynchronous sequences
[<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module AsyncSeq =
    /// Creates an empty asynchronous sequence that immediately ends
    [<GeneralizableValue>]
    [<CompiledName("Empty")>]
    let empty<'T> : AsyncSeq<'T> =
        asyncSeq.Zero ()

    /// Creates an asynchronous sequence that generates a single element and then ends
    [<CompiledName("Singleton")>]
    let singleton (value : 'T) : AsyncSeq<'T> =
        asyncSeq.Yield value

    /// Yields all elements of the first asynchronous sequence and then 
    /// all elements of the second asynchronous sequence.
    [<CompiledName("Append")>]
    let rec append (aseq1 : AsyncSeq<'T>) (aseq2 : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "aseq1" aseq1
        checkNonNull "aseq2" aseq2

        asyncSeq.Combine (aseq1, aseq2)

    /// Creates an asynchronous sequence that iterates over the given input sequence.
    /// For every input element, it calls the the specified function and iterates
    /// over all elements generated by that asynchronous sequence.
    /// This is the 'bind' operation of the computation expression (exposed using
    /// the 'for' keyword in asyncSeq computation).
    [<CompiledName("Collect")>]
    let rec collect mapping (aseq : AsyncSeq<'T>) : AsyncSeq<'U> =
        // Preconditions
        checkNonNull "aseq" aseq

        asyncSeq.For (aseq, mapping)

    // --------------------------------------------------------------------------
    // Additional combinators (implemented as async/asyncSeq computations)

    /// Builds a new asynchronous sequence whose elements are generated by 
    /// applying the specified function to all elements of the input sequence.
    ///
    /// The specified function is asynchronous (and the input sequence will
    /// be asked for the next element after the processing of an element completes).
    [<CompiledName("MapAsync")>]
    let mapAsync mapping (input : AsyncSeq<'T>) : AsyncSeq<'U> =
        // Preconditions
        checkNonNull "input" input

        asyncSeq {
        for itm in input do
            let! v = mapping itm
            yield v
        }

    /// Asynchronously iterates over the input sequence and generates 'x' for 
    /// every input element for which the specified asynchronous function 
    /// returned 'Some(x)' 
    ///
    /// The specified function is asynchronous (and the input sequence will
    /// be asked for the next element after the processing of an element completes).
    [<CompiledName("ChooseAsync")>]
    let chooseAsync chooser (input : AsyncSeq<'T>) : AsyncSeq<'U> =
        // Preconditions
        checkNonNull "input" input

        asyncSeq {
        for itm in input do
            let! v = chooser itm
            match v with
            | None -> ()
            | Some v ->
                yield v
        }

    /// Builds a new asynchronous sequence whose elements are those from the
    /// input sequence for which the specified function returned true.
    ///
    /// The specified function is asynchronous (and the input sequence will
    /// be asked for the next element after the processing of an element completes).
    [<CompiledName("FilterAsync")>]
    let filterAsync predicate (input : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        asyncSeq {
        for v in input do
            let! b = predicate v
            if b then
                yield v }

    /// Asynchronously returns the last element that was generated by the
    /// given asynchronous sequence (or the specified default value).
    [<CompiledName("LastOrDefault")>]
    let rec lastOrDefault defaultValue (input : AsyncSeq<'T>) =
        // Preconditions
        checkNonNull "input" input

        async {
        let! v = input
        match v with
        | Nil ->
            return defaultValue
        | Cons (h, t) ->
            return! lastOrDefault h t }

    /// Asynchronously returns the first element that was generated by the
    /// given asynchronous sequence (or the specified default value).
    [<CompiledName("FirstOrDefault")>]
    let firstOrDefault defaultValue (input : AsyncSeq<'T>) =
        // Preconditions
        checkNonNull "input" input

        async {
        let! v = input
        match v with
        | Nil ->
            return defaultValue
        | Cons(h, _) ->
            return h }

    /// Aggregates the elements of the input asynchronous sequence using the
    /// specified 'aggregation' function. The result is an asynchronous
    /// sequence of intermediate aggregation result.
    ///
    /// The aggregation function is asynchronous (and the input sequence will
    /// be asked for the next element after the processing of an element completes).
    [<CompiledName("ScanAsync")>]
    let rec scanAsync folder (state : 'State) (input : AsyncSeq<'T>) : AsyncSeq<'State> =
        // Preconditions
        checkNonNull "input" input

        asyncSeq {
        let! v = input
        match v with
        | Nil -> ()
        | Cons (h, t) ->
            let! v = folder state h
            yield v
            yield! scanAsync folder v t }

    /// Iterates over the input sequence and calls the specified function for
    /// every value (to perform some side-effect asynchronously).
    ///
    /// The specified function is asynchronous (and the input sequence will
    /// be asked for the next element after the processing of an element completes).
    [<CompiledName("IterAsync")>]
    let rec iterAsync action (input : AsyncSeq<'T>) =
        // Preconditions
        checkNonNull "input" input

        async {
        for itm in input do
            do! action itm }

    /// Returns an asynchronous sequence that returns pairs containing an element
    /// from the input sequence and its predecessor. Empty sequence is returned for
    /// singleton input sequence.
    [<CompiledName("Pairwise")>]
    let rec pairwise (input : AsyncSeq<'T>) : AsyncSeq<'T * 'T> =
        // Preconditions
        checkNonNull "input" input

        asyncSeq {
        let! v = input
        match v with
        | Nil -> ()
        | Cons(h, t) ->
            let prev = ref h
            for v in t do
                yield (!prev, v)
                prev := v }

    /// Aggregates the elements of the input asynchronous sequence using the
    /// specified 'aggregation' function. The result is an asynchronous 
    /// workflow that returns the final result.
    ///
    /// The aggregation function is asynchronous (and the input sequence will
    /// be asked for the next element after the processing of an element completes).
    [<CompiledName("FoldAsync")>]
    let rec foldAsync folder (state : 'State) (input : AsyncSeq<'T>) =
        // Preconditions
        checkNonNull "input" input

        input |> scanAsync folder state |> lastOrDefault state

    /// Same as AsyncSeq.foldAsync, but the specified function is synchronous
    /// and returns the result of aggregation immediately.
    [<CompiledName("Fold")>]
    let rec fold folder (state : 'State) (input : AsyncSeq<'T>) =
        // Preconditions
        checkNonNull "input" input

        foldAsync (fun st v -> folder st v |> async.Return) state input

    /// Same as AsyncSeq.scanAsync, but the specified function is synchronous
    /// and returns the result of aggregation immediately.
    [<CompiledName("Scan")>]
    let rec scan folder (state : 'State) (input : AsyncSeq<'T>) : AsyncSeq<'State> =
        // Preconditions
        checkNonNull "input" input

        scanAsync (fun st v -> folder st v |> async.Return) state input

    /// Same as AsyncSeq.mapAsync, but the specified function is synchronous
    /// and returns the result of projection immediately.
    [<CompiledName("Map")>]
    let map mapping (input : AsyncSeq<'T>) =
        // Preconditions
        checkNonNull "input" input

        mapAsync (mapping >> async.Return) input

    /// Same as AsyncSeq.iterAsync, but the specified function is synchronous
    /// and performs the side-effect immediately.
    [<CompiledName("Iter")>]
    let iter action (input : AsyncSeq<'T>) =
        // Preconditions
        checkNonNull "input" input

        iterAsync (action >> async.Return) input

    /// Same as AsyncSeq.chooseAsync, but the specified function is synchronous
    /// and processes the input element immediately.
    [<CompiledName("Choose")>]
    let choose chooser (input : AsyncSeq<'T>) : AsyncSeq<'U> =
        // Preconditions
        checkNonNull "input" input

        chooseAsync (chooser >> async.Return) input

    /// Same as AsyncSeq.filterAsync, but the specified predicate is synchronous
    /// and processes the input element immediately.
    [<CompiledName("Filter")>]
    let filter predicate (input : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        filterAsync (predicate >> async.Return) input

    // --------------------------------------------------------------------------
    // Converting from/to synchronous sequences or IObservables

    /// Creates an asynchronous sequence that lazily takes element from an
    /// input synchronous sequence and returns them one-by-one.
    [<CompiledName("OfSeq")>]
    let ofSeq (input : seq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        asyncSeq {
        for el in input do
            yield el }

    /// A helper type for implementation of buffering when converting 
    /// observable to an asynchronous sequence
    type internal BufferMessage<'T> =
        | Get of AsyncReplyChannel<'T>
        | Put of 'T

    /// Converts observable to an asynchronous sequence using an agent with
    /// a body specified as the argument. The returnd async sequence repeatedly 
    /// sends 'Get' message to the agent to get the next element. The observable
    /// sends 'Put' message to the agent (as new inputs are generated).
    let internal ofObservableUsingAgent (input : System.IObservable<'T>) f : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        asyncSeq {
        use agent = AutoCancelAgent.Start (f)
        use d =
            input
            |> Observable.asUpdates
            |> Observable.subscribe (Put >> agent.Post)
      
        let rec loop () =
            asyncSeq {
            let! msg = agent.PostAndAsyncReply(Get)
            match msg with
            | ObservableUpdate.Completed -> ()
            | ObservableUpdate.Error e ->
                raise e
            | ObservableUpdate.Next v ->
                yield v
                yield! loop() }

        yield! loop() }

    /// Converts observable to an asynchronous sequence. Values that are produced
    /// by the observable while the asynchronous sequence is blocked are stored to 
    /// an unbounded buffer and are returned as next elements of the async sequence.
    [<CompiledName("FromObservableBuffered")>]
    let ofObservableBuffered (input : System.IObservable<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        ofObservableUsingAgent input <| fun mbox ->
            async {
            let buffer = System.Collections.Generic.Queue<_> ()
            let replies = System.Collections.Generic.Queue<_> ()
            while true do
                // Receive next message (when observable ends, caller will
                // cancel the agent, so we need timeout to allow cancleation)
                let! msg = mbox.TryReceive(200)
                match msg with
                | None -> ()
                | Some (Put value) ->
                    buffer.Enqueue value
                | Some (Get reply) ->
                    replies.Enqueue reply
                
                // Process matching calls from buffers
                while buffer.Count > 0 && replies.Count > 0 do
                    buffer.Dequeue ()
                    |> replies.Dequeue().Reply
            }

    /// Converts observable to an asynchronous sequence. Values that are produced
    /// by the observable while the asynchronous sequence is blocked are discarded
    /// (this function doesn't guarantee that asynchronou ssequence will return 
    /// all values produced by the observable)
    [<CompiledName("FromObservable")>]
    let ofObservable (input : System.IObservable<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        ofObservableUsingAgent input <| fun mbox ->
            async {
            while true do
                // Allow timeout (when the observable ends, caller will
                // cancel the agent, so we need timeout to allow cancellation)
                let! msg = mbox.TryReceive(200)
                match msg with
                | None
                | Some (Put _) ->
                    ()  // Ignore put or no message.
                | Some (Get repl) ->
                    // Reader is blocked, so next will be Put
                    // (caller will not stop the agent at this point,
                    // so timeout is not necessary)
                    let! v = mbox.Receive ()
                    match v with
                    | Put v ->
                        repl.Reply v
                    | _ ->
                        failwith "Unexpected Get" }

    /// Converts asynchronous sequence to an IObservable<_>. When the client subscribes
    /// to the observable, a new copy of asynchronous sequence is started and is 
    /// sequentially iterated over (at the maximal possible speed). Disposing of the 
    /// observer cancels the iteration over asynchronous sequence.
    [<CompiledName("ToObservable")>]
    let toObservable (aseq : AsyncSeq<'T>) =
        // Preconditions
        checkNonNull "aseq" aseq

        let start (obs : IObserver<_>) =
            async {
                try
                    for v in aseq do
                        obs.OnNext v
                    obs.OnCompleted()
                with e ->
                    obs.OnError e }
            |> Async.StartDisposable

        { new IObservable<_> with
            member x.Subscribe(obs) = start obs }

    /// Converts asynchronous sequence to a synchronous blocking sequence.
    /// The elements of the asynchronous sequence are consumed lazily.
    [<CompiledName("ToBlockingSeq")>]
    let toBlockingSeq (input : AsyncSeq<'T>) =
        // Preconditions
        checkNonNull "input" input

        // Write all elements to a blocking buffer and then add None to denote end
        let buf = BlockingQueueAgent<_> (1)
        async {
            do! iterAsync (Some >> buf.AsyncAdd) input
            do! buf.AsyncAdd None }
        |> Async.Start

        // Read elements from the blocking buffer & return a sequences
        let rec loop () =
            seq {
            match buf.Get () with
            | None -> ()
            | Some value ->
                yield value
                yield! loop () }
        loop ()

    /// Create a new asynchronous sequence that caches all elements of the 
    /// sequence specified as the input. When accessing the resulting sequence
    /// multiple times, the input will still be evaluated only once
    [<CompiledName("Cache")>]
    let rec cache (input : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        let agent = Agent<AsyncReplyChannel<_>>.Start <| fun agent ->
            async {
            let! repl = agent.Receive ()
            let! next = input
            let res =
                match next with 
                | Nil -> Nil
                | Cons(h, t) ->
                    Cons(h, cache t)
            repl.Reply res
            while true do
                let! repl = agent.Receive ()
                repl.Reply res }

        //
        async { return! agent.PostAndAsyncReply(id) }

    /// Combines two asynchronous sequences into a sequence of pairs. 
    /// The values from sequences are retrieved in parallel.
    [<CompiledName("Zip")>]
    let rec zip (input1 : AsyncSeq<'T1>) (input2 : AsyncSeq<'T2>) : AsyncSeq<_> =
        // Preconditions
        checkNonNull "input1" input1
        checkNonNull "input2" input2

        async {
        let! ft = Async.StartChild input1
        let! s = input2
        let! f = ft
        match f, s with
        | Cons(hf, tf), Cons(hs, ts) ->
            return Cons( (hf, hs), zip tf ts)
        | _ -> return Nil }

    /// Returns the first N elements of an asynchronous sequence
    [<CompiledName("Take")>]
    let rec take count (input : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        async {
        if count > 0 then
            let! v = input
            match v with
            | Nil ->
                return Nil
            | Cons(h, t) ->
                return Cons(h, take (count - 1) t)
        else return Nil }

    /// Returns elements from an asynchronous sequence while the specified 
    /// predicate holds. The predicate is evaluated asynchronously.
    [<CompiledName("TakeWhileAsync")>]
    let rec takeWhileAsync predicate (input : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        async {
        let! v = input
        match v with
        | Nil ->
            return Nil
        | Cons(h, t) ->
            let! res = predicate h
            if res then
                return Cons(h, takeWhileAsync predicate t)
            else return Nil }

    /// Returns elements from an asynchronous sequence while the specified 
    /// predicate holds. The predicate is evaluated synchronously.
    [<CompiledName("TakeWhile")>]
    let rec takeWhile predicate (input : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        takeWhileAsync (predicate >> async.Return) input

    /// Skips the first N elements of an asynchronous sequence and
    /// then returns the rest of the sequence unmodified.
    [<CompiledName("Skip")>]
    let rec skip count (input : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        async {
        if count > 0 then
            let! v = input
            match v with
            | Nil ->
                return Nil
            | Cons(_, t) ->
                return! skip (count - 1) t
        else return! input }

    /// Skips elements from an asynchronous sequence while the specified 
    /// predicate holds and then returns the rest of the sequence. The 
    /// predicate is evaluated asynchronously.
    [<CompiledName("SkipWhileAsync")>]
    let rec skipWhileAsync predicate (input : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        async {
        let! v = input
        match v with
        | Nil ->
            return Nil
        | Cons (h, t) ->
            let! res = predicate h
            if res then return! skipWhileAsync predicate t
            else return! t }

    /// Skips elements from an asynchronous sequence while the specified 
    /// predicate holds and then returns the rest of the sequence. The 
    /// predicate is evaluated asynchronously.
    [<CompiledName("SkipWhile")>]
    let rec skipWhile predicate (input : AsyncSeq<'T>) : AsyncSeq<'T> =
        // Preconditions
        checkNonNull "input" input

        skipWhileAsync (predicate >> async.Return) input

(*
//
module Seq = 
    open ExtCore.Control

    /// Converts asynchronous sequence to a synchronous blocking sequence.
    /// The elements of the asynchronous sequence are consumed lazily.
    let ofAsyncSeq (input : AsyncSeq<'T>) =
        AsyncSeq.toBlockingSeq input

*)
